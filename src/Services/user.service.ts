// import { IRepository } from '../Interfaces/IRepository'
// import { IUser } from '../Interfaces/IUser'
// import { IResult } from '../Interfaces/IResult'
// import { injectable } from 'inversify'
// import { User } from '../Models/users'
// import "reflect-metadata";
// import { Document, Types } from 'mongoose'

// // business layer
// @injectable() // decorator
// class UserService implements IRepository {

//     //get all users
//     async getUsers() { // asynchronous func.
//         try {
//             const users = await User.find({})
//             return users
//         } catch (error) {
//             console.log(error)
//         }
//     }

//     //get a single user
//     async getUser(id: string) {
//         try {
//             const user = await User.findById({ _id: id })
//             if (!user) {
//                 return '404'
//             }
//                 return user
            
//         } catch (error) {
//             console.log(error)
//             return '404';
//         }
//     }
//     //create a user
//     async createUser(data: any) {
//         try {
//             const newUser = await User.create(data)
//             return newUser
//         } catch (error) {
//             console.log(error)
//         }
//     }

//     //update a user
//     async updateUser(id: string, data: any) {
//         try {
//             //pass the id of the object you want to update
//             //data is for the new body you are updating the old one with
//             //new:true, so the dats being returned, is the update one
//             const users = await User.findByIdAndUpdate({ _id: id }, data, { new: true })
//             if (!users) {
//                 return "user not available"
//             }
//             return users
//         } catch (error) {
//             console.log(error)
//         }
//     }

//     //delete a user by using the find by id and delete 
//     async deleteUser(id: string) {
//         try {
//             const user = await User.findByIdAndDelete(id)
//             if (!user) {
//                 return 'user not available'
//             }
//         } catch (error) {
//             console.log(error)
//         }
//     }

//     async patchUpdate(id: string, data: any) {
//         try {
//             const updatedOne = await User.updateOne(
//                 { _id: id },
//                 { $set: data }
//             );
//             return updatedOne
//         } catch (err) {
//             console.log(err);
//         }

//     }

//     async getChunk(queryPool: {
//         sortType: string,
//         pageIndex: number,
//         orderBy: 1 | -1,
//         filter: {
//             edad: {
//                 $gte: number;
//                 $lte: number;
//             };
//         }
//     }, limit: number = 5) {
//         //const pagination = new Pagination(queryPool.pageIndex, limit); // pass page-index and limit

//         let items: (Document<unknown, any, IUser> & IUser & {
//             _id: Types.ObjectId;
//         })[]

// /*         if(queryPool.filter){
//             items = await User.find(queryPool.filter)
//             .sort({ [queryPool.sortType]: queryPool.orderBy }) // id is automatically generated by mongodb so users requested according to createdAt
//             .skip((queryPool.pageIndex - 1) * limit) // first user, get users by index
//             .limit(limit) // last user
//         }else{ */
//             items = await User.find(/* queryPool.filter */)
//             .sort({ [queryPool.sortType]: queryPool.orderBy }) // id is automatically generated by mongodb so users requested according to createdAt
//             .skip((queryPool.pageIndex - 1) * limit) // first user, get users by index
//             .limit(limit) // last user
        

//         const result: IResult = {
//             total: await User.countDocuments(),
//             limit: limit,
//             users: items
//         }
//         return result
//     }

//     async search(q: string, queryPool: {
//         sortType: string,
//         pageIndex: number,
//         orderBy: 1 | -1
//     }, limit: number = 2) {
//         try {
//             console.log(q)
//             // that's a exact string match solution, mongoDB doesn't support partial match search but can be found solutions...
//             const answer = await User.find({ $text: { $search: q, $caseSensitive: true } })
//                  .sort({[queryPool.sortType]: queryPool.orderBy })
//                 .skip((queryPool.pageIndex - 1) * limit)
//                 .limit(limit)

//             const result: IResult = {
//                 total: answer.length,
//                 limit: limit,
//                 users: answer
//             }
//             return result
//         } catch (error) { console.log(error) }
//     }
// }

// export { UserService } 
import { IRepository } from '../Interfaces/IRepository'
import { IUser } from '../Interfaces/IUser'
import { IResult } from '../Interfaces/IResult'
import { injectable } from 'inversify'
import { User } from '../Models/users'
import "reflect-metadata";
import { Document, Types } from 'mongoose'

// business layer
@injectable() // decorator
class UserService implements IRepository {

    //get all users
    async getUsers() { // asynchronous func.
        try {
            const users = await User.find({})
            return users
        } catch (error) {
            console.log(error)
        }
    }

    //get a single user
    async getUser(id: string) {
        try {
            const user = await User.findById({ _id: id })
            if (!user) {
                return '404'
            }
                return user
            
        } catch (error) {
            console.log(error)
            return '404';
        }
    }
    //create a user
    async createUser(data: any) {
        try {
            const newUser = await User.create(data)
            return newUser
        } catch (error) {
            console.log(error)
        }
    }

    //update a user
    async updateUser(id: string, data: any) {
        try {
            //pass the id of the object you want to update
            //data is for the new body you are updating the old one with
            //new:true, so the dats being returned, is the update one
            const users = await User.findByIdAndUpdate({ _id: id }, data, { new: true })
            if (!users) {
                return "user not available"
            }
            return users
        } catch (error) {
            console.log(error)
        }
    }

    //delete a user by using the find by id and delete 
    async deleteUser(id: string) {
        try {
            const user = await User.findByIdAndDelete(id)
            if (!user) {
                return 'user not available'
            }
        } catch (error) {
            console.log(error)
        }
    }

    async patchUpdate(id: string, data: any) {
        try {
            const updatedOne = await User.updateOne(
                { _id: id },
                { $set: data }
            );
            return updatedOne
        } catch (err) {
            console.log(err);
        }

    }

// //    static async getChunk(queryPool: {
// //         sortType: string,
// //         pageIndex: number,
// //         orderBy: 1 | -1,
// //         filter: {
// //             edad: {
// //                 $gte: number;
// //                 $lte: number;
// //             };
// //         }
// //     }, limit: number = 5) {
// //         //const pagination = new Pagination(queryPool.pageIndex, limit); // pass page-index and limit

// //         let items: (Document<unknown, any, IUser> & IUser & {
// //             _id: Types.ObjectId;
// //         })[]

// // /*         if(queryPool.filter){
// //             items = await User.find(queryPool.filter)
// //             .sort({ [queryPool.sortType]: queryPool.orderBy }) // id is automatically generated by mongodb so users requested according to createdAt
// //             .skip((queryPool.pageIndex - 1) * limit) // first user, get users by index
// //             .limit(limit) // last user
// //         }else{ */
// //             items = await User.find(/* queryPool.filter */)
// //             .sort({ [queryPool.sortType]: queryPool.orderBy }) // id is automatically generated by mongodb so users requested according to createdAt
// //             .skip((queryPool.pageIndex - 1) * limit) // first user, get users by index
// //             .limit(limit) // last user
        

// //         const result: IResult = {
// //             total: await User.countDocuments(),
// //             limit: limit,
// //             users: items
// //         }
// //         return result
// //     }

    async search(q: string, queryPool: {
        sortType: string,
        pageIndex: number,
        orderBy: 1 | -1
    }, limit: number = 2) {
        try {
            console.log(q)
            // that's a exact string match solution, mongoDB doesn't support partial match search but can be found solutions...
            const answer = await User.find({ $text: { $search: q, $caseSensitive: true } })
                 .sort({[queryPool.sortType]: queryPool.orderBy })
                .skip((queryPool.pageIndex - 1) * limit)
                .limit(limit)

            const result: IResult = {
                total: answer.length,
                limit: limit,
                users: answer
            }
            return result
        } catch (error) { console.log(error) }
    }
}

export { UserService } 
